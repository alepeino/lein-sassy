(ns leiningen.lein-sassy.renderer
  (:require
    [clojure.string :as s]
    [hawk.core :as hawk]
    [leiningen.core.main :as lmain]
    [leiningen.lein-sassy.file-utils :refer :all]
    [me.raynes.fs :as fs]
    [zweikopf.core :as z])
  (:import
    (java.text SimpleDateFormat)
    (java.util Base64 Date)))


(defn- print-message [& args]
  (lmain/info (apply str (.format (SimpleDateFormat. "[yyyy-MM-dd HH:mm:ss] ") (Date.)) args)))

(defn- render-with-sourcemap
  [file options]
  (let [outpath (dest-path (str file) (:src options) (:dst options))
        map-type (or (#{:inline} (:sourcemap options)) :auto)
        map-options {:type :auto :css_path outpath :sourcemap_path (map-file outpath)}
        map-uri (fs/base-name (:sourcemap_path map-options))
        engine (z/call-ruby "Sass::Engine" "new" (slurp file) (z/rubyize options))
        [css sourcemap] (z/call-ruby engine "render_with_sourcemap" map-uri)
        map-json (z/call-ruby sourcemap "to_json" (z/rubyize map-options))]
    (case map-type
      :inline [(s/replace css (str "sourceMappingURL=" map-uri)
                              (str "sourceMappingURL=data:application/json;base64,"
                                (.encodeToString (Base64/getEncoder) (.getBytes map-json))))
               nil]
      :auto [css (str map-json \newline)])))

(defn- render
  [file options]
  (let [engine (z/call-ruby "Sass::Engine" "new" (slurp file) (z/rubyize options))
        css (z/call-ruby engine "render")]
    [css nil]))

(defn render-file
  "Renders one file and returns the rendered result and the sourcemap."
  [file options]
  (let [syntax (get-file-syntax file options)
        options (assoc options :syntax syntax :filename (str file))]
    (try (if (:sourcemap options)
           (render-with-sourcemap file options)
           (render file options))
      (catch Exception e (print-message "Compilation failed:" e)))))

(defn- spit-files! [css sourcemap outpath map-type]
  (fs/mkdirs (fs/parent outpath))
  (spit outpath css)
  (when (and sourcemap (not (= :inline map-type)))
    (spit (map-file outpath) sourcemap)))

(defn render-all!
  "Renders all templates in the directory specified by (:src options)."
  [options]
  (doseq [file (fs/find-files* (:src options) compilable-sass-file?)]
    (let [inpath (str file)
          outpath (dest-path inpath (:src options) (:dst options))
          [css sourcemap] (render-file file options)]
      (print-message inpath " to " outpath)
      (spit-files! css sourcemap outpath (:sourcemap options)))))

(defn- file-change-handler
  "Prints the file that was changed then renders all templates."
  [options file]
  (when (sass-file? file)
    (print-message "File " file " changed.")
    (render-all! options)))

(defn watch-and-render!
  "Watches the directory specified by (:src options) and calls a handler that
  renders all templates."
  [options]
  (print-message "Watching " (:src options) " for changes.")
  (print-message "Type \"exit\" to stop.")
  (let [watcher (hawk/watch! [{:paths [(:src options)]
                               :handler (fn [_ {:keys [kind file]}]
                                          (when (= :modify kind)
                                            (file-change-handler options file)))}])]
    (while (not= (read-line) "exit"))
    (hawk/stop! watcher)))

(defn clean-all!
  [{:keys [dst delete-output-dir]}]
  (lmain/info "Deleting files generated by lein-sass in" dst)
  (if delete-output-dir
    (delete-dir! dst)
    (doseq [file (fs/find-files* dst (comp #{css-extension} fs/extension))]
      (delete-file! file)
      (delete-file! (map-file file)))))
